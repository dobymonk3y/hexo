[{"title":"1.了解Go语言的命令源码文件","url":"/2019/07/22/1-了解Go语言的命令源码文件/","content":"\n# 命令源码文件\n\n[toc]\n\n\n\n![命令源码文件基础知识图](http://new.bengder.cc/img/2-1.png)\n\n\n> Hello World\n\n通过简单的Hello World程序了解命令源码, 那么:\n\n命令源码文件的用途是什么? 怎么编写?\n\n```\n命令源码文件是程序的运行入口, 是每个可独立运行的程序必须拥有的. 我们可以通过构建或者安装, 生成与其对应的可执行文件, 后者一般会与该命令源码文件的直接父目录同名\n```\n\n**如果一个源码文件生命属于main包,并且包含一个无参数声明且无结果声明的main函数, 那么它就是命令源码文件.** 就如下面这段代码\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n    fmt.Println(\"Hello world!\")\n}\n```\n\n把上面的代码命名为`demo1.go`, 运行命令行`go run demo1.go`后, 就会在屏幕(标准输出)中看到 Hello world!\n\n那么, 命令源码文件怎样接收参数呢?\n\n## 命令源码文件接收参数\n\n```\npackage main\n\nimport(\n    \"flag\"\n    \"fmt\"\n)\n\nvar name string\n\nfunc init(){\n    // flag.StringVar(&变量名,接收变量值,默认值,注释)\n\t// 查看使用方法或者参数说明 go run demo1.go --help\n    flag.StringVar(&name,\"name\",\"everyone\",\"The greeting object!\")\n}\n\nfunc main(){\n    flag.Parse()\n    fmt.Printf(\"Hello %s!\\n\", name)\n}\n\n```\n\n上述代码命名为 `demo2.go`, 那么怎样传入参数呢?\n\n```\n$ go run demo2.go -name \"frankie\"\n```\n\n那么如何自定义命令源码文件的参数使用说明呢?\n\n## 自定义命令源码文件的参数使用说明\n\n这里我们使用`flag.Usage`重新赋值. flag.Usage的类型是func(). 即一种五参数生命且无结果声明的函数类型. \n\n复制 demo2.go 为 demo3.go\n\n```\npackage main\n\nimport(\n    \"flag\"\n    \"fmt\"\n)\n\nvar name string\n\nfunc init(){\n    // flag.StringVar(&变量名,接收变量值,默认值,注释)\n\t// 查看使用方法或者参数说明 go run demo1.go --help\n    flag.StringVar(&name,\"name\",\"everyone\",\"The greeting object!\")\n}\n\nfunc main(){\n\tflag.Usage = func() {\n    \tfmt.Fprintf(os.Stderr, \"Usage of %s:\\n\", \"Question\")\n    \tflag.PrintDefaults()\n\t}\n    flag.Parse()\n    fmt.Printf(\"Hello %s!\\n\", name)\n}\n\n```\n\n执行命令 `go run demo3.go --help` 后就会看到如下结果\n\n```\nUsage of Question:\n    -n string\n        The greeting object. (default \"everyone\")\nexit status 2\n```\n\n我们在调用flag包中的一些函数的时候, 实际上是在调用flag.CommandLine变量的对应方法. \n\nflag.CommandLine 相当于默认情况下的命令参数容器. 所以通过 flag.CommandLine重新赋值, 我们就可以修改命令源码文件的参数使用说明. \n\n现在我们把main函数体重的那条对 flag.Usage变量的赋值语句注释掉, 然后在init函数体的开始出添加如下代码:\n\n```\nflag.CommandLine = flag.NewFlagSet(\"\",flag.ExitOnError)\nflag.CommandLine.Usage = func(){\n    fmt.Fprintf(os.Stderr, \"Usage of %s! \\n\",\"Question\")\n    fmt.PrintDefaults()\n}\n```\n\n修改后的完整代码:\n\n```demo3.go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar name string\n\nfunc init() {\n\tflag.CommandLine = flag.NewFlagSet(\"\", flag.ExitOnError)\n\tflag.CommandLine.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"Usage of %s!\\n\", \"Question\")\n\t\tflag.PrintDefaults()\n\t}\n\tflag.StringVar(&name, \"name\", \"everyone\", \"The greeting object.\")\n}\n\nfunc main() {\n\tflag.Parse()\n\tfmt.Printf(\"Hello, %s!\\n\", name)\n}\n```\n\n执行 `go run demo3.go --help` 后显示结果与上面方法一致.\n\n```\nUsage of Question:\n    -n string\n        The greeting object. (default \"everyone\")\nexit status 2\n```\n\n下面我们尝试修改\n\n> flag.CommandLine = flag.NewFlagSet(\"\", flag.ExitOnError)\n\n为\n\n> flag.CommandLine = flag.NewFlagSet(\"\", flag.PanicOnError)\n\n执行 `go run demo3.go --help` 后你会发现显示结果换了另外一种效果.\n\n```\nUsage of Question!\n  -name string\n        The greeting object. (default \"everyone\")\npanic: flag: help requested\n\ngoroutine 1 [running]:\nflag.(*FlagSet).Parse(0xc000098060, 0xc00005a430, 0x1, 0x1, 0xc00008df88, 0x405466)\n        C:/Go/src/flag/flag.go:983 +0xffflag.Parse(...)\n        C:/Go/src/flag/flag.go:998\nmain.main()\n        E:/Users/frankie/go/src/demo/demo1.go:21 +0x7f\nexit status 2\n```\n\n**++flag.ExitOnError 与 flag.PanicOnError都是预定义在flag包中的常量++**\n\nflag.ExitOnErr的含义是,告诉命令参数容器, 当命令后跟`--help`或者参数设置不正确时,打印命令参数使用说明后以状态码2结束当前程序\n\n状态码2代表用户错误地使用了命令, 而flag.PanicOnError与之的区别是最后抛出`运行时恐慌`\n\n上述两种情况都会在调用flag.Parse函数时触发.\n\n## 创建私有命令参数容器\n\n我们在函数外再添加一个变量声明\n\n```\nvar cmdLine = flag.NewFlagSet(\"Question\",flag.ExitOnError)\n```\n\n然后我们把对falg.StringVar的调用替换为 cmdLine.StringVar调用, 再把 flag.Parse()替换为cmdLine.Parse(os.Args[1:])\n\n**++其中 os.Args[1:]指的就是我们给定的那些命令参数. 这样做就完全脱离了flag.CommandLine. 这样做的好处是更灵活地定制了命令参数容器. 更重要的是, 定制完全不会影响到全局变量flag.CommandLine++**\n\n","tags":["Golang"]},{"title":"Golang学习笔记","url":"/2019/07/20/Golang学习笔记/","content":"\n\n# Golang 学习笔记\n\n## Go常用命令简介\n- go get      获取远程包\n- go run      直接运行程序\n- go build    测试编译,检查是否有编译错误\n- go fmt      格式化源码(部分IED在保存时自动调用)\n- go install  编译包文件并编译整个程序\n- go test     运行测试文件\n- go do       查看文档\n\n\n## Go 的25个内置关键字\n\n- break     default     func    interface   select\n- case      defer       go      map         struct\n- chan      else        goto    package     switch\n- const     fallthrough if      range       type\n- continue  for         import return       var\n\n\n## Go 的注释方式\n\n- // 单行注释\n- /* */多行注释\n\n\n## 工作区和PATH\n\n安装后我们需要配置3个环境变量 `GOROOT` `GOPATH` `GOBIN`\n\n- GOROOT: Go语言安装根目录的路径,也就是Go的安装路径\n- GOPATH: 若干工作区目录的路径,是我们自己定义的工作空间\n- GOBIN: GO 程序生成的可执行文件（executable file）...\n\n> 面试题: 设置GOPATH有什么意义?\n\n把GOPATH简单理解成工作区, 它的值是一个目录的路径, 在该目录下的每一个目录, 都代表着各自的工作区域. 我们需要用这些工作区域去放置Go源码文件,以及安装后的归档文件和可执行文件\n\n\n### Go语言源码的组织方式\n\nGO语言的源码以代码包为基本组织单位. 在文件系统中, 代码包与目录一一对应. 目录可以有子目录, 代码包也可以有子包.\n\n一个代码包中可以包含任意个以\".go\"为扩展名的源文件, 这些源文件都要被声明属于同一个代码包\n\n代码包的名称一般会与源码文件所在的目录同名. 如果不同名, 那么在构建、安装的过程中会以代码包名称为准.\n\n每个代码包都会有导入路径. 代码包的导入路径是其他代码在使用该包中的程序实体时, 需要引入的路径. 在实际使用程序实体之前, 我们必须先导入其所在的代码包. 具体方式就是 `import` 该代码包的导入路径, For example: \n\n```\nimport \"github.com/labstack/echo\"\n```\n\n在工作区中, 一个代码包的导入路径实际上就是`src`子目录, 到该包的实际存储位置的相对路径.\n\n所以说, Go语言源码的组织方式就是以环境变量GOPATH、工作区，src目录和代码包为主线。一般情况下，Go语言的源码文件都需要被存放在环境变量GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中.\n\n### 源码安装后的结果\n\n源码文件通常会被放在某个工作区内的src目录下. 安装后如果产生了归档文件(以\".a\"为扩展名的文件), 就会放进该工作区的pkg子目录; 如果产生了可执行文件, 就可能会放进该工作区的bin子目录.\n\n> 归档文件存放的具体位置和规则\n\n源码文件会以代码包的形式组织起来, 一个代码包其实就对应一个目录. 安装某个代码包而产生的归档文件是与这个代码包同名的. \n\n放置它的相对目录就是该代码包的导入路径的直接父级. \n\n示例: 一个已经存在的代码包的导入路径是 \n\n```\ngithub.com/labstack/echo\n```\n\n执行命令\n\n```\ngo install github.com/labstack/echo\n```\n\n生成的归档文件的相对目录就是 `github.com/labstack` 文件名为 `echo.a`\n\n> 扩展: 代码包的另外一层含义: 该代码包的源码文件存在于 Github.com 网站的 labstack(User) 组的代码仓库 echo(Property) 中.\n\n归档文件的相对目录与pkg目录之间还有一级目录, 叫做平台相关目录. 平台相关目录的名称是由 `build` (也称\"构建\")的目标操作系统、下划线和目标计算架构的代号组成的。\n\n比如,构建某个代码包时的目标系统是Linux,目标计算架构是64位的, 那么对应的平台相关目录就是 `linux_amd64`\n\n因此,上述代码包的归档文件就会被放置在当前工作区的子目录 `pkg/linux_amd64/github.com/labstack`中\n\n![代码包归档文件放置在当前工作区的子目录 图示 1-1](http://new.bengder.cc/img/1-1.png)\n\n### 理解构建和安装Go程序的过程\n\n构建使用命令 `go build`, 安装使用命令 `go install` . 构建和安装代码包的时候都会执行编译、打包等操作. 并且这些操作生成的任何文件都会先被保存到某个临时的目录中.\n\n如果构建的是 `库源码` 文件, 那么操作后产生的结果文件只会存在于临时目录中. 这里的`构建`的主要意义在于检查和验证. \n\n如果构建的是 `命令源码` 文件, 那么操作后产生的结果会被搬运到源码文件所在的目录中. \n\n安装操作会先执行构建, 然后还会进行链接操作, 并且把结果文件搬运到指定目录.\n\n进一步说, 如果安装的库源码文件, 那么结果文件会被搬运到它所在工作区的pkg目录下的某个子目录中; 如果安装的是命令源码文件, 那么结果文件会被搬运到它所在工作区的bin目录中, 或者环境变量GOBIN指向的目录中.\n\n### 拓展\n\n#### go build 命令一些可选项的用途和用法\n\n- `-a` 在使用go build命令时添加标记 `-a`, 强制编译目标代码包所依赖的代码包\n- `-i` 安装归档文件使用标记 `-i`\n\n#### 如何确定哪些包被编译了?\n\n1. 运行 go build 命令时加入标记`-x`,可以查看go build命令具体执行了哪些操作, 加入标记 `-n`, 可以只查看具体操作而不执行.\n2. 运行 go build 命令时加入标记`-v`,可以查看go build命令编译的代码包的名称,与`-a`标记搭配使用(推荐).\n\n#### go get 常用标记\n\n该命令会自动从一些代码仓库下载目标代码包,并把它们安装到GOPATH包含的`第一个工作区`的相应目录中. 如果存在环境变量GOBIN, 那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录\n\n最常用的几个标记:\n\n- `-u`          下载并安装代码包, 不论工作区中是否已存在它们\n- `-d`          只下载代码包, 不安装代码包\n- `-fix`        在下载代码包后先运行一个用于根据当前Go语言版本修正代码的工具, 再安装代码包\n- `-t`          同事下载测试所需的代码包\n- `-insecure`   允许通过非安全的网络协议下载和安装代码包. HTTP就是这样的协议\n\n#### 自定义导入路径 (导入注释)\n\n出于某种目的变更存储源码的代码仓库或者代码包的相对路径, 为了让代码包的远程导入路径不受此类变更的影响, 我们应该使用自定义的代码包导入路径.\n\n自定义的方法是: 在该代码包中的库源码文件的包生命语句的右边加入导入注释: \n\n```\npackage semaphore // import \"golang.org/x/sync/semaphore\"\n```\n\n这个代码包原本的完整导入路径是`github.com/golang/sync/semaphore` , 这与实际存储它的网络地址对应的. 该代码包的源码实际存在Github网站的 golang 组的 sync 代码仓库的 semaphore 目录下. 而加入导入注释之后, 用一下命令即可下载并安装该代码包\n```\ngo get golang.org/x/sync/semaphore\n```\n\n而Go语言官网 golang.org 下的路径 /x/sync/semaphore 并不是存放 semaphore 包的真实地址,我们称之为代码包的自定义导入路径\n\n\n## 命令源码文件\n\n![命令源码文件知识点 图示 2-1](http://new.bengder.cc/img/2-1.png)\n\n\n\n\n\n\n\n## Go 程序的一般结构\n- Go程序是通过 **package** 来组织的\n- 只有package名称为main的包可以包含main函数\n- 一个可执行程序 **有且仅有** 一个main包\n- 通过关键字**import**导入非main包的其它包\n- 通过关键字**const**来进行 **常量** 的定义\n- 通过在函数体外部使用**var**关键字来进行全局变量的声明与赋值\n- 使用**type**关键字来进行结构(**struct**)或者接口(**interface**)的声明\n- 通过**func**关键字来进行函数的声明\n","tags":["Golang"]},{"title":"redis-server errors","url":"/2019/07/20/redis-server-errors/","content":"\n> WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\n```\n$ vim /etc/sysctl.conf\n# 添加下面代码\nnet.core.somaxconn= 1024 \n```\n\n> 如何让redis-server 以进程方式启动\n\n```\n# 修改 redis.conf\ndaemonize no  ->  daemonize yes\n$ redis-server ./你redis的安装目录/redis.conf\n```\n\n> WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\n\n```\n$ vim /etc/sysctl.conf\n# 添加如下代码后 退出\nvm.overcommit_memory=1\n# 退出后执行操作\n$ sysctl -p\n```\n\n> WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.\n\n\n> 在使用redis-cli连接redis-server后, set 中文, get 中文时显示非汉字,这里redis-cli采用了16进制的显示方法显示了汉字\n\n```\nredis-cli --raw\n```","tags":["Redis"]},{"title":"Hello World","url":"/2019/07/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"Redis Notes","url":"/2019/07/19/Redis-Notes/","content":"\n# Redis 学习笔记\n\n\n\n\n\n- 什么是队列? 什么是栈?\n    - 队列是先进先出, 栈是先进后出.\n\n- 原子操作:\n    - 指将一系列的操作看作成一个整体,不可中断,开始执行到结束.\n- MySQL 与 NoSQL 的区别?\n    - MySQL是关系型数据库, NoSQL是非关系型数据库\n    - 存储方式不同: MySQL数据存在特定结构的表中;NoSQL可以存在json文档中,hash表中或其它方式\n    - 数据关系不同:MySQL必须建立好表,确定关系,才能存储数据;而在NoSQL中,不限时间不限地点都可以进行数据存储\n    - 外部存储数据:SQL中增加外部数据时,是在原表中增加外键,关联外部数据;而NoSQL则可以集中放置数据.\n    - JOIN查询:MySQL使用join做集合查询,而NoSQL没有提供这种交集查询方式.\n    - 事务处理:MySQL多张表同批次进行数据操作,就是通过事务处理的,其中一张表失败,其它表更新也会失败.NoSQL没有事务概念.\n- NoSQL优势:\n    - 灵活的可扩展性\n    - 维护成本低\n    - 大数据的处理能力\n    - 灵活的数据类型\n    - 数据存储的成本低,通过商业服务器集群管理膨胀的数据\n- NoSQL劣势:\n    - 单产品成熟度不够\n    - 后续技术支持后劲不足\n    - 分析能力和商业智能化血线淡泊\n    - 缺乏高精尖专业人才\n\n\n\n## Redis 的增删改查\n\n> 常用命令\n\n```\n    set key     插入数据\n    get key     查询数据\n    del key     删除数据\n    getset key  修改数据\n    exists key  验证key是否存在\n```\n\n## Redis常用数据类型\n\n> string 类型\n\n是Redis中二进制、最简单的key-value类型,最大数据上限1G.\n\n\n\n## string 类型数据常用命令\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| set| set key value| 设置指定key的值|\n|2| get| get key| 获取指定key的值|\n|3| getrange|getrange key start end| 返回key中字符串的子字符(下标从0开始)|\n|4| getset| getset key value| 修改指定key的值,并返回key的旧值|\n|5| getbit| getbit key offset| 对key所储存的字符串值, 获取指定偏移量上的位(bit)|\n|6| mget| mget key1 key2| 获取一个或多个给定key的值|\n|7| setbit| setbit key offset value| 对key所储存的字符串值,设置或清除指定偏移量上的位(bit)|\n|8| setex| setex key seconds value| 将值value关联到key,并将key的过期时间设为seconds(以秒为单位)|\n|9| setnx| setnx key value| 只有在key不存在时设置key的值为value|\n|10|setrange|setrange key offset value| 用value参数覆写给定key所储存的字符串值,从偏移量offset开始|\n|11|strlen| strlen key| 返回key所储存的字符串值的长度|\n|12|mset|mset key value [key value]|同时设置一个或多个key-value对|\n|13|msetnx|msetnx key value[key value]|同时设置一个或多个key-value对,当且仅当所有给定key都不存在|\n|14|psetex|psetex key milliseconds value|这个命令和 setex 命令相似,但它以毫秒为单位设置key的生存时间|\n|15|incr|incr key| 将key中储存的数字值 +1|\n|16|incrby| incrby key increment| 将key所储存的值加上给定的增量值|\n|17|incrbyfloat| incrbyfloat key increment| 将key所储存的值加上给定的浮点增量值|\n|18|decr| decr key| 将key中储存的数字值 -1|\n|19|decyby| decrby key decrement| key所储存的值减去给定的减量值|\n|20|append| append key value| 如果key已经存在并且是一个字符串,将value追加到key值的末尾|\n\n\n## Redis中list类型及操作\n\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| lpush| lpush key value| 将一个或多个值插入到已存在的列表头部|\n|2| rpush| rpush key value| 将一个或多个值插入到已存在的列表尾部|\n|3| linsert| linsert key before/after pivot value|在列表的元素前或后插入元素|\n|4| lset| lset key index value|通过索引设置列表元素的值|\n|5| lrem| lrem key count value|移除列表元素|\n|6| ltrim| ltrim key start stop| 对一个列表进行修剪(trim), 列表保留指定区域内的元素|\n|7| lrange| lrange key start stop|获取列表中的某一片段|\n|8| lpop| lpop key|移出并获取列表的第一个元素|\n|9| rpop| rpop key|移出兵获取列表的最后一个元素|\n|10|rpoplpush| rpoplpush source destination|移除列表的最后一个元素,并将该元素添加到另外一个列表并返回|\n|11|lindex| lindex key index|通过索引获取列表的元素|\n|12|llen| llen key|获取列表长度|\n\n\n## Redis中hash类型及操作\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| hset| hset key field value|将哈希表中key中字段field的值设为value|\n|2| hget| hget key field|获取储存在哈希表中指定字段的值|\n|3| hmget| hmget key field1 ... fieldN|获取所有给定字段的值|\n|4| hmset| hmset key field1 value1 ... fieldN valueN|同时设置到哈希表中多个field|\n|5| hincrby| hincrby key filed increment|为哈希表key中指定字段加上给定值|\n|6| hexists| hexists key field|查看哈希表key中是否存在filed字段|\n|7| hdel | hdel key field| 删除一个或多个哈希字段|\n|8| hlen| hlen key|获取哈希表中字段的数量|\n|9| hkeys| hkeys key|获取哈希表中所有字段|\n|10|hvals| hvals key|获取哈希表中所有的值|\n|11|hgetall| hgetall key|获取哈希表中指定key的所有字段和值|\n\n\n## Redis中sets类型及操作\n\n数学中的集合,对集合进行添加,删除以及获取交集差集等操作.\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| sadd| sadd key member1[ member2]|向集合中添加一个或者多个元素|\n|2| srem| srem key member1[ member2]|移除集合中一个或者多个元素|\n|3| smembers| smembers key|返回集合中所有元素|\n|4| spop| spop key|移除并返回集合中的一个随机元素|\n|5| sdiff| sdiff key1[key2]|返回key2中没有key1的所有元素差集|\n|6| sdiffstore| sdiffstore destination key1 key2|返回给定所有集合的差集兵存储在destination中|\n|7| sinter|sinter key1 key2| 返回给定所有集合的交集|\n|8| sinterstore| sinterstore destination key1 key2|返回给定所有集合的交集并存储在destination中|\n|9| sunion| sunion key1 key2| 返回给定所有集合的并集|\n|10|sunionstore|sunionstore destination key1 key2|返回所有给定集合的并集 存储在destination中|\n|11|smove| smove source destination member| 将member元素从source集合移动到destination集合|\n|12|scard| scard key member|获取集合成员数|\n|13|sismember|sismember key member|判断member元素是否是集合key的成员|\n|14|srandmember| srandmember key[count]|返回集合中一个或多个随机数|\n\n## Redis中zsets类型及操作\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| zadd| zadd key score1 member|添加member元素到集合key, 若元素在集合中存在,则更新对应的score|\n|2| zrem| zrem key member| 删除指定元素,1表示成功,如果元素不存在则返回0|\n|3| zincrby| zincby key incr member| 有序集合中对指定成员的score增加对应增量,返回更新后的score值|\n|4| zrank| zrank key member|返回有序集合中指定成员的索引|\n|5| zrevrank| zrevrank key member| 返回有序集合中指定成员的排名,有序集合成员按分数值递减排序|\n|6| zrange| zrange key start end|通过索引区间返回有序集合成指定区域内的成员|\n|7| zrevrange| zrevrange key start end|返回集合中指定区间内的成员,通过索引,分数从高到低|\n|8| zrangebyscore| zrangebyscore key min max| 通过分数返回有序集合指定区间内的成员|\n|9| zcount| zcount key min max|计算在有序集合中指定区间分数的成员数|\n|10|zcard| zcard key| 获取有序集合的成员数|\n|11|zscore|zscore key element| 返回有序集合中,成员的分数值|\n|12|zremrangebyrank| zremrangebyrank key min max| 移除有序集合中给定的排名区间的所有成员|\n|13|zremrangebyscore| zremrangebyscore key min max| 移除有序集合中给定的分数区间的所有成员|\n\n\n## Redis中常用命令及操作 \n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| keys| keys pattern| 返回符合给定要求的所有key|\n|2| exists| exists key| 判断key是否存在|\n|3| del| del key| 删除一个key|\n|4| expire| expire key seconds| 设置一个key的过期时间, 单位:秒|\n|5| move| move key db| 当前key 移到其它db数据库中|\n|6| persist| persist key| 移除key的过期时间|\n|7| randomkey| randomkey -| 随机返回key空间的一个key|\n|8| rename| rename key| 重命名key|\n|9| type| type key| 返回key所对应value的类型|\n\n## Redis中的订阅/发布\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| subscribe| subscribe channel| 订阅给定的一个或多个频道的信息|\n|2| publish| publish channel message| 将信息发送给指定的频道 channel|\n|3| psubscribe | psubscribe pattern| 订阅一个或多个符合给定模式的频道|\n|4| pubsub| pubsub subcommand| 查看订阅与发布系统状态|\n|5| punsubscribe| punsubscrib pattern|退出所有给定模式的频道|\n|6| unsubscribe| unsubscribe channel| 退出给定的频道|\n\n## Redis服务器的相关命令\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| ping| ping [message]|测试连接是否存活|\n|2| echo| echo message|在命令行打印一些内容|\n|3| select| select index| 选择数据库|\n|4| quit| quit | 退出连接|\n|5| dbsize| dbsize| 返回当前数据库中key的数目|\n|6| info| info section| 获取服务器的信息和统计|\n|7| config get| config get|获取服务器配置信息|\n|8| flushdb| flushdb| 删除当前选择数据库中的所有key|\n|9| flushall| flushall| 删除所有数据库中的所有key|\n\n# Redis主从复制实现\n\n1. 首先创建 6380 6381两个文件夹,复制`redis.conf`至目录下,并修改配置文件端口号与文件夹一致\n2. 开启服务 `redis-server ./6380/redis.conf`、`redis-server ./6381/redis.conf`\n3. 创建实例连接服务端`redis-cli -p 6380`、`redis-cli -p 6381`\n4. 在`6380`端口数据库中使用 `slaveof 127.0.0.1 6381` 配置主从\n    \n返回 `ok` 后 在`6380`端口客户端执行 `info replication`查看信息(我本地是windows测试)\n\n```\nE:\\>\\soft\\redis\\redis-cli -p 6380\n127.0.0.1:6380> info replication\n# Replication\nrole:slave # 当前角色 slave 代表从数据库\nmaster_host:127.0.0.1   # 主数据库IP\nmaster_port:6381        # 主数据库端口\nmaster_link_status:up\nmaster_last_io_seconds_ago:7\nmaster_sync_in_progress:0\nslave_repl_offset:141\nslave_priority:100\nslave_read_only:1\nconnected_slaves:0\nmaster_repl_offset:0\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n127.0.0.1:6380>\n```\n\n在`6381`端口客户端执行 `info replication` 查看信息(本地windows)\n```\nE:\\>\\soft\\redis\\redis-cli -p 6381\n127.0.0.1:6381> info replication\n# Replication\nrole:master # 当前角色 master 代表主数据库\nconnected_slaves:1 # 已连接从数据库数量\nslave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=0\nmaster_repl_offset:281\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:2\nrepl_backlog_histlen:280\n127.0.0.1:6381>\n```\n\n5. 停止端口号为`6381`的redis服务器(模拟`6381`主服务器出现问题无法使用等情况)\n6. 开启端口号为`6381`的redis服务器,并设定`6381`端口数据库为端口号`6380`数据库的从库\n```\nredis-server --port 6380 --slaveof 127.0.0.1 6381\n```\n连接端口号为`6381`的redis客户端,使用`info replication`命令查询状态\n```\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:1\nslave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=0\nmaster_repl_offset:281\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:2\nrepl_backlog_histlen:280\n127.0.0.1:6381>\n```\n\n> 权限认证\n\n\n为了安全,通常`master`主库配置文件中会使用`requirepass`,而在`slave`从库中要做`masterauth`权限认证\n\n\n\n## 跨IP连接Redis-server\n\n以IP为`192.168.44.130`作为`Redis-sever`,以`192.168.44.128`作为`Redis-cli`连接\n\n修改`Redis-server`配置文件,保证`protected-mode`值为`yes`,查找`bind` 注释掉`bind 127.0.0.1`\n\n查找 `requirepass`, 在下方写入(注意密码复杂度)\n```\nrequirepass myPass\n```\n\n保存退出\n\n在IP为`192.168.44.128`客户端上输入一下命令尝试连接`Reids-server`\n```\n# 连接Redis-server\nredis-cli -h 192.168.44.130 -p 6379\nAUTH myPass\n```\n\n\n## Redis哨兵的创建与实现\n\n建立哨兵方式 1:\n\n> redis-sentinel /path/to/sentinel.conf\n\n建立哨兵方式 2:\n\n> redis-server /path/to/sentinel.conf --sentinel\n\n`Sentinel`的配置\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 60000\n```\n\n解析:\n\n> 其中`mymaster`表示要监控的主数据库的名字,后两个参数表示主数据库的地址和端口号,这里我们要监控的是主数据库6379, 最后的`2`表示最低通过票数,当集群中有2个哨兵认为`mymaster`挂掉时,才能真正认为该master已经不可用了.而`down-after-milliseconds`表示每隔一定时间(单位:毫秒)发送一个`ping`命令,请求Server响应,来判断主数据库是否可用","tags":["Redis"]}]