[{"title":"redis-server errors","url":"/2019/07/20/redis-server-errors/","content":"\n> WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\n```\n$ vim /etc/sysctl.conf\n# 添加下面代码\nnet.core.somaxconn= 1024 \n```\n\n> 如何让redis-server 以进程方式启动\n\n```\n# 修改 redis.conf\ndaemonize no  ->  daemonize yes\n$ redis-server ./你redis的安装目录/redis.conf\n```\n\n> WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\n\n```\n$ vim /etc/sysctl.conf\n# 添加如下代码后 退出\nvm.overcommit_memory=1\n# 退出后执行操作\n$ sysctl -p\n```\n\n> WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.\n\n\n> 在使用redis-cli连接redis-server后, set 中文, get 中文时显示非汉字,这里redis-cli采用了16进制的显示方法显示了汉字\n\n```\nredis-cli --raw\n```","tags":["Redis"]},{"title":"Hello World","url":"/2019/07/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"Redis Notes","url":"/2019/07/19/Redis-Notes/","content":"\n# Redis 学习笔记\n\n\n\n\n\n- 什么是队列? 什么是栈?\n    - 队列是先进先出, 栈是先进后出.\n\n- 原子操作:\n    - 指将一系列的操作看作成一个整体,不可中断,开始执行到结束.\n- MySQL 与 NoSQL 的区别?\n    - MySQL是关系型数据库, NoSQL是非关系型数据库\n    - 存储方式不同: MySQL数据存在特定结构的表中;NoSQL可以存在json文档中,hash表中或其它方式\n    - 数据关系不同:MySQL必须建立好表,确定关系,才能存储数据;而在NoSQL中,不限时间不限地点都可以进行数据存储\n    - 外部存储数据:SQL中增加外部数据时,是在原表中增加外键,关联外部数据;而NoSQL则可以集中放置数据.\n    - JOIN查询:MySQL使用join做集合查询,而NoSQL没有提供这种交集查询方式.\n    - 事务处理:MySQL多张表同批次进行数据操作,就是通过事务处理的,其中一张表失败,其它表更新也会失败.NoSQL没有事务概念.\n- NoSQL优势:\n    - 灵活的可扩展性\n    - 维护成本低\n    - 大数据的处理能力\n    - 灵活的数据类型\n    - 数据存储的成本低,通过商业服务器集群管理膨胀的数据\n- NoSQL劣势:\n    - 单产品成熟度不够\n    - 后续技术支持后劲不足\n    - 分析能力和商业智能化血线淡泊\n    - 缺乏高精尖专业人才\n\n\n\n## Redis 的增删改查\n\n> 常用命令\n\n```\n    set key     插入数据\n    get key     查询数据\n    del key     删除数据\n    getset key  修改数据\n    exists key  验证key是否存在\n```\n\n## Redis常用数据类型\n\n> string 类型\n\n是Redis中二进制、最简单的key-value类型,最大数据上限1G.\n\n\n\n## string 类型数据常用命令\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| set| set key value| 设置指定key的值|\n|2| get| get key| 获取指定key的值|\n|3| getrange|getrange key start end| 返回key中字符串的子字符(下标从0开始)|\n|4| getset| getset key value| 修改指定key的值,并返回key的旧值|\n|5| getbit| getbit key offset| 对key所储存的字符串值, 获取指定偏移量上的位(bit)|\n|6| mget| mget key1 key2| 获取一个或多个给定key的值|\n|7| setbit| setbit key offset value| 对key所储存的字符串值,设置或清除指定偏移量上的位(bit)|\n|8| setex| setex key seconds value| 将值value关联到key,并将key的过期时间设为seconds(以秒为单位)|\n|9| setnx| setnx key value| 只有在key不存在时设置key的值为value|\n|10|setrange|setrange key offset value| 用value参数覆写给定key所储存的字符串值,从偏移量offset开始|\n|11|strlen| strlen key| 返回key所储存的字符串值的长度|\n|12|mset|mset key value [key value]|同时设置一个或多个key-value对|\n|13|msetnx|msetnx key value[key value]|同时设置一个或多个key-value对,当且仅当所有给定key都不存在|\n|14|psetex|psetex key milliseconds value|这个命令和 setex 命令相似,但它以毫秒为单位设置key的生存时间|\n|15|incr|incr key| 将key中储存的数字值 +1|\n|16|incrby| incrby key increment| 将key所储存的值加上给定的增量值|\n|17|incrbyfloat| incrbyfloat key increment| 将key所储存的值加上给定的浮点增量值|\n|18|decr| decr key| 将key中储存的数字值 -1|\n|19|decyby| decrby key decrement| key所储存的值减去给定的减量值|\n|20|append| append key value| 如果key已经存在并且是一个字符串,将value追加到key值的末尾|\n\n\n## Redis中list类型及操作\n\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| lpush| lpush key value| 将一个或多个值插入到已存在的列表头部|\n|2| rpush| rpush key value| 将一个或多个值插入到已存在的列表尾部|\n|3| linsert| linsert key before/after pivot value|在列表的元素前或后插入元素|\n|4| lset| lset key index value|通过索引设置列表元素的值|\n|5| lrem| lrem key count value|移除列表元素|\n|6| ltrim| ltrim key start stop| 对一个列表进行修剪(trim), 列表保留指定区域内的元素|\n|7| lrange| lrange key start stop|获取列表中的某一片段|\n|8| lpop| lpop key|移出并获取列表的第一个元素|\n|9| rpop| rpop key|移出兵获取列表的最后一个元素|\n|10|rpoplpush| rpoplpush source destination|移除列表的最后一个元素,并将该元素添加到另外一个列表并返回|\n|11|lindex| lindex key index|通过索引获取列表的元素|\n|12|llen| llen key|获取列表长度|\n\n\n## Redis中hash类型及操作\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| hset| hset key field value|将哈希表中key中字段field的值设为value|\n|2| hget| hget key field|获取储存在哈希表中指定字段的值|\n|3| hmget| hmget key field1 ... fieldN|获取所有给定字段的值|\n|4| hmset| hmset key field1 value1 ... fieldN valueN|同时设置到哈希表中多个field|\n|5| hincrby| hincrby key filed increment|为哈希表key中指定字段加上给定值|\n|6| hexists| hexists key field|查看哈希表key中是否存在filed字段|\n|7| hdel | hdel key field| 删除一个或多个哈希字段|\n|8| hlen| hlen key|获取哈希表中字段的数量|\n|9| hkeys| hkeys key|获取哈希表中所有字段|\n|10|hvals| hvals key|获取哈希表中所有的值|\n|11|hgetall| hgetall key|获取哈希表中指定key的所有字段和值|\n\n\n## Redis中sets类型及操作\n\n数学中的集合,对集合进行添加,删除以及获取交集差集等操作.\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| sadd| sadd key member1[ member2]|向集合中添加一个或者多个元素|\n|2| srem| srem key member1[ member2]|移除集合中一个或者多个元素|\n|3| smembers| smembers key|返回集合中所有元素|\n|4| spop| spop key|移除并返回集合中的一个随机元素|\n|5| sdiff| sdiff key1[key2]|返回key2中没有key1的所有元素差集|\n|6| sdiffstore| sdiffstore destination key1 key2|返回给定所有集合的差集兵存储在destination中|\n|7| sinter|sinter key1 key2| 返回给定所有集合的交集|\n|8| sinterstore| sinterstore destination key1 key2|返回给定所有集合的交集并存储在destination中|\n|9| sunion| sunion key1 key2| 返回给定所有集合的并集|\n|10|sunionstore|sunionstore destination key1 key2|返回所有给定集合的并集 存储在destination中|\n|11|smove| smove source destination member| 将member元素从source集合移动到destination集合|\n|12|scard| scard key member|获取集合成员数|\n|13|sismember|sismember key member|判断member元素是否是集合key的成员|\n|14|srandmember| srandmember key[count]|返回集合中一个或多个随机数|\n\n## Redis中zsets类型及操作\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| zadd| zadd key score1 member|添加member元素到集合key, 若元素在集合中存在,则更新对应的score|\n|2| zrem| zrem key member| 删除指定元素,1表示成功,如果元素不存在则返回0|\n|3| zincrby| zincby key incr member| 有序集合中对指定成员的score增加对应增量,返回更新后的score值|\n|4| zrank| zrank key member|返回有序集合中指定成员的索引|\n|5| zrevrank| zrevrank key member| 返回有序集合中指定成员的排名,有序集合成员按分数值递减排序|\n|6| zrange| zrange key start end|通过索引区间返回有序集合成指定区域内的成员|\n|7| zrevrange| zrevrange key start end|返回集合中指定区间内的成员,通过索引,分数从高到低|\n|8| zrangebyscore| zrangebyscore key min max| 通过分数返回有序集合指定区间内的成员|\n|9| zcount| zcount key min max|计算在有序集合中指定区间分数的成员数|\n|10|zcard| zcard key| 获取有序集合的成员数|\n|11|zscore|zscore key element| 返回有序集合中,成员的分数值|\n|12|zremrangebyrank| zremrangebyrank key min max| 移除有序集合中给定的排名区间的所有成员|\n|13|zremrangebyscore| zremrangebyscore key min max| 移除有序集合中给定的分数区间的所有成员|\n\n\n## Redis中常用命令及操作 \n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| keys| keys pattern| 返回符合给定要求的所有key|\n|2| exists| exists key| 判断key是否存在|\n|3| del| del key| 删除一个key|\n|4| expire| expire key seconds| 设置一个key的过期时间, 单位:秒|\n|5| move| move key db| 当前key 移到其它db数据库中|\n|6| persist| persist key| 移除key的过期时间|\n|7| randomkey| randomkey -| 随机返回key空间的一个key|\n|8| rename| rename key| 重命名key|\n|9| type| type key| 返回key所对应value的类型|\n\n## Redis中的订阅/发布\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| subscribe| subscribe channel| 订阅给定的一个或多个频道的信息|\n|2| publish| publish channel message| 将信息发送给指定的频道 channel|\n|3| psubscribe | psubscribe pattern| 订阅一个或多个符合给定模式的频道|\n|4| pubsub| pubsub subcommand| 查看订阅与发布系统状态|\n|5| punsubscribe| punsubscrib pattern|退出所有给定模式的频道|\n|6| unsubscribe| unsubscribe channel| 退出给定的频道|\n\n## Redis服务器的相关命令\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| ping| ping [message]|测试连接是否存活|\n|2| echo| echo message|在命令行打印一些内容|\n|3| select| select index| 选择数据库|\n|4| quit| quit | 退出连接|\n|5| dbsize| dbsize| 返回当前数据库中key的数目|\n|6| info| info section| 获取服务器的信息和统计|\n|7| config get| config get|获取服务器配置信息|\n|8| flushdb| flushdb| 删除当前选择数据库中的所有key|\n|9| flushall| flushall| 删除所有数据库中的所有key|\n\n# Redis主从复制实现\n\n1. 首先创建 6380 6381两个文件夹,复制`redis.conf`至目录下,并修改配置文件端口号与文件夹一致\n2. 开启服务 `redis-server ./6380/redis.conf`、`redis-server ./6381/redis.conf`\n3. 创建实例连接服务端`redis-cli -p 6380`、`redis-cli -p 6381`\n4. 在`6380`端口数据库中使用 `slaveof 127.0.0.1 6381` 配置主从\n    \n返回 `ok` 后 在`6380`端口客户端执行 `info replication`查看信息(我本地是windows测试)\n\n```\nE:\\>\\soft\\redis\\redis-cli -p 6380\n127.0.0.1:6380> info replication\n# Replication\nrole:slave # 当前角色 slave 代表从数据库\nmaster_host:127.0.0.1   # 主数据库IP\nmaster_port:6381        # 主数据库端口\nmaster_link_status:up\nmaster_last_io_seconds_ago:7\nmaster_sync_in_progress:0\nslave_repl_offset:141\nslave_priority:100\nslave_read_only:1\nconnected_slaves:0\nmaster_repl_offset:0\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n127.0.0.1:6380>\n```\n\n在`6381`端口客户端执行 `info replication` 查看信息(本地windows)\n```\nE:\\>\\soft\\redis\\redis-cli -p 6381\n127.0.0.1:6381> info replication\n# Replication\nrole:master # 当前角色 master 代表主数据库\nconnected_slaves:1 # 已连接从数据库数量\nslave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=0\nmaster_repl_offset:281\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:2\nrepl_backlog_histlen:280\n127.0.0.1:6381>\n```\n\n5. 停止端口号为`6381`的redis服务器(模拟`6381`主服务器出现问题无法使用等情况)\n6. 开启端口号为`6381`的redis服务器,并设定`6381`端口数据库为端口号`6380`数据库的从库\n```\nredis-server --port 6380 --slaveof 127.0.0.1 6381\n```\n连接端口号为`6381`的redis客户端,使用`info replication`命令查询状态\n```\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:1\nslave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=0\nmaster_repl_offset:281\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:2\nrepl_backlog_histlen:280\n127.0.0.1:6381>\n```\n\n> 权限认证\n\n\n为了安全,通常`master`主库配置文件中会使用`requirepass`,而在`slave`从库中要做`masterauth`权限认证\n\n\n\n## 跨IP连接Redis-server\n\n以IP为`192.168.44.130`作为`Redis-sever`,以`192.168.44.128`作为`Redis-cli`连接\n\n修改`Redis-server`配置文件,保证`protected-mode`值为`yes`,查找`bind` 注释掉`bind 127.0.0.1`\n\n查找 `requirepass`, 在下方写入(注意密码复杂度)\n```\nrequirepass myPass\n```\n\n保存退出\n\n在IP为`192.168.44.128`客户端上输入一下命令尝试连接`Reids-server`\n```\n# 连接Redis-server\nredis-cli -h 192.168.44.130 -p 6379\nAUTH myPass\n```\n\n\n## Redis哨兵的创建与实现\n\n建立哨兵方式 1:\n\n> redis-sentinel /path/to/sentinel.conf\n\n建立哨兵方式 2:\n\n> redis-server /path/to/sentinel.conf --sentinel\n\n`Sentinel`的配置\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 60000\n```\n\n解析:\n\n> 其中`mymaster`表示要监控的主数据库的名字,后两个参数表示主数据库的地址和端口号,这里我们要监控的是主数据库6379, 最后的`2`表示最低通过票数,当集群中有2个哨兵认为`mymaster`挂掉时,才能真正认为该master已经不可用了.而`down-after-milliseconds`表示每隔一定时间(单位:毫秒)发送一个`ping`命令,请求Server响应,来判断主数据库是否可用","tags":["Redis"]}]