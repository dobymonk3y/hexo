[{"title":"Golang学习笔记","url":"/2019/07/20/Golang学习笔记/","content":"\n\n# Golang 学习笔记\n\n## Go常用命令简介\n- go get      获取远程包\n- go run      直接运行程序\n- go build    测试编译,检查是否有编译错误\n- go fmt      格式化源码(部分IED在保存时自动调用)\n- go install  编译包文件并编译整个程序\n- go test     运行测试文件\n- go do       查看文档\n\n\n## Go 的25个内置关键字\n\n- break     default     func    interface   select\n- case      defer       go      map         struct\n- chan      else        goto    package     switch\n- const     fallthrough if      range       type\n- continue  for         import return       var\n\n\n## Go 的注释方式\n\n- // 单行注释\n- /* */多行注释\n\n\n## 工作区和PATH\n\n安装后我们需要配置3个环境变量 `GOROOT` `GOPATH` `GOBIN`\n\n- GOROOT: Go语言安装根目录的路径,也就是Go的安装路径\n- GOPATH: 若干工作区目录的路径,是我们自己定义的工作空间\n- GOBIN: GO 程序生成的可执行文件（executable file）...\n\n> 面试题: 设置GOPATH有什么意义?\n\n把GOPATH简单理解成工作区, 它的值是一个目录的路径, 在该目录下的每一个目录, 都代表着各自的工作区域. 我们需要用这些工作区域去放置Go源码文件,以及安装后的归档文件和可执行文件\n\n### 知识扩展\n\n#### Go语言源码的组织方式\n\nGO语言的源码以代码包为基本组织单位. 在文件系统中, 代码包与目录一一对应. 目录可以有子目录, 代码包也可以有子包.\n\n一个代码包中可以包含任意个以\".go\"为扩展名的源文件, 这些源文件都要被声明属于同一个代码包\n\n代码包的名称一般会与源码文件所在的目录同名. 如果不同名, 那么在构建、安装的过程中会以代码包名称为准.\n\n每个代码包都会有导入路径. 代码包的导入路径是其他代码在使用该包中的程序实体时, 需要引入的路径. 在实际使用程序实体之前, 我们必须先导入其所在的代码包. 具体方式就是 `import` 该代码包的导入路径, For example: \n\n```\nimport \"github.com/labstack/echo\"\n```\n\n在工作区中, 一个代码包的导入路径实际上就是`src`子目录, 到该包的实际存储位置的相对路径.\n\n所以说, Go语言源码的组织方式就是以环境变量GOPATH、工作区，src目录和代码包为主线。一般情况下，Go语言的源码文件都需要被存放在环境变量GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中.\n\n#### 源码安装后的结果\n\n源码文件通常会被放在某个工作区内的src目录下. 安装后如果产生了归档文件(以\".a\"为扩展名的文件), 就会放进该工作区的pkg子目录; 如果产生了可执行文件, 就可能会放进该工作区的bin子目录.\n\n> 归档文件存放的具体位置和规则\n\n源码文件会以代码包的形式组织起来, 一个代码包其实就对应一个目录. 安装某个代码包而产生的归档文件是与这个代码包同名的. \n\n放置它的相对目录就是该代码包的导入路径的直接父级. \n\n示例: 一个已经存在的代码包的导入路径是 \n\n```\ngithub.com/labstack/echo\n```\n\n执行命令\n\n```\ngo install github.com/labstack/echo\n```\n\n生成的归档文件的相对目录就是 `github.com/labstack` 文件名为 `echo.a`\n\n> 扩展: 代码包的另外一层含义: 该代码包的源码文件存在于 Github.com 网站的 labstack(User) 组的代码仓库 echo(Property) 中.\n\n\n\n\n\n\n## Go 程序的一般结构\n- Go程序是通过 **package** 来组织的\n- 只有package名称为main的包可以包含main函数\n- 一个可执行程序 **有且仅有** 一个main包\n- 通过关键字**import**导入非main包的其它包\n- 通过关键字**const**来进行 **常量** 的定义\n- 通过在函数体外部使用**var**关键字来进行全局变量的声明与赋值\n- 使用**type**关键字来进行结构(**struct**)或者接口(**interface**)的声明\n- 通过**func**关键字来进行函数的声明\n","tags":["Golang"]},{"title":"redis-server errors","url":"/2019/07/20/redis-server-errors/","content":"\n> WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\n```\n$ vim /etc/sysctl.conf\n# 添加下面代码\nnet.core.somaxconn= 1024 \n```\n\n> 如何让redis-server 以进程方式启动\n\n```\n# 修改 redis.conf\ndaemonize no  ->  daemonize yes\n$ redis-server ./你redis的安装目录/redis.conf\n```\n\n> WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\n\n```\n$ vim /etc/sysctl.conf\n# 添加如下代码后 退出\nvm.overcommit_memory=1\n# 退出后执行操作\n$ sysctl -p\n```\n\n> WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.\n\n\n> 在使用redis-cli连接redis-server后, set 中文, get 中文时显示非汉字,这里redis-cli采用了16进制的显示方法显示了汉字\n\n```\nredis-cli --raw\n```","tags":["Redis"]},{"title":"Hello World","url":"/2019/07/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"Redis Notes","url":"/2019/07/19/Redis-Notes/","content":"\n# Redis 学习笔记\n\n\n\n\n\n- 什么是队列? 什么是栈?\n    - 队列是先进先出, 栈是先进后出.\n\n- 原子操作:\n    - 指将一系列的操作看作成一个整体,不可中断,开始执行到结束.\n- MySQL 与 NoSQL 的区别?\n    - MySQL是关系型数据库, NoSQL是非关系型数据库\n    - 存储方式不同: MySQL数据存在特定结构的表中;NoSQL可以存在json文档中,hash表中或其它方式\n    - 数据关系不同:MySQL必须建立好表,确定关系,才能存储数据;而在NoSQL中,不限时间不限地点都可以进行数据存储\n    - 外部存储数据:SQL中增加外部数据时,是在原表中增加外键,关联外部数据;而NoSQL则可以集中放置数据.\n    - JOIN查询:MySQL使用join做集合查询,而NoSQL没有提供这种交集查询方式.\n    - 事务处理:MySQL多张表同批次进行数据操作,就是通过事务处理的,其中一张表失败,其它表更新也会失败.NoSQL没有事务概念.\n- NoSQL优势:\n    - 灵活的可扩展性\n    - 维护成本低\n    - 大数据的处理能力\n    - 灵活的数据类型\n    - 数据存储的成本低,通过商业服务器集群管理膨胀的数据\n- NoSQL劣势:\n    - 单产品成熟度不够\n    - 后续技术支持后劲不足\n    - 分析能力和商业智能化血线淡泊\n    - 缺乏高精尖专业人才\n\n\n\n## Redis 的增删改查\n\n> 常用命令\n\n```\n    set key     插入数据\n    get key     查询数据\n    del key     删除数据\n    getset key  修改数据\n    exists key  验证key是否存在\n```\n\n## Redis常用数据类型\n\n> string 类型\n\n是Redis中二进制、最简单的key-value类型,最大数据上限1G.\n\n\n\n## string 类型数据常用命令\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| set| set key value| 设置指定key的值|\n|2| get| get key| 获取指定key的值|\n|3| getrange|getrange key start end| 返回key中字符串的子字符(下标从0开始)|\n|4| getset| getset key value| 修改指定key的值,并返回key的旧值|\n|5| getbit| getbit key offset| 对key所储存的字符串值, 获取指定偏移量上的位(bit)|\n|6| mget| mget key1 key2| 获取一个或多个给定key的值|\n|7| setbit| setbit key offset value| 对key所储存的字符串值,设置或清除指定偏移量上的位(bit)|\n|8| setex| setex key seconds value| 将值value关联到key,并将key的过期时间设为seconds(以秒为单位)|\n|9| setnx| setnx key value| 只有在key不存在时设置key的值为value|\n|10|setrange|setrange key offset value| 用value参数覆写给定key所储存的字符串值,从偏移量offset开始|\n|11|strlen| strlen key| 返回key所储存的字符串值的长度|\n|12|mset|mset key value [key value]|同时设置一个或多个key-value对|\n|13|msetnx|msetnx key value[key value]|同时设置一个或多个key-value对,当且仅当所有给定key都不存在|\n|14|psetex|psetex key milliseconds value|这个命令和 setex 命令相似,但它以毫秒为单位设置key的生存时间|\n|15|incr|incr key| 将key中储存的数字值 +1|\n|16|incrby| incrby key increment| 将key所储存的值加上给定的增量值|\n|17|incrbyfloat| incrbyfloat key increment| 将key所储存的值加上给定的浮点增量值|\n|18|decr| decr key| 将key中储存的数字值 -1|\n|19|decyby| decrby key decrement| key所储存的值减去给定的减量值|\n|20|append| append key value| 如果key已经存在并且是一个字符串,将value追加到key值的末尾|\n\n\n## Redis中list类型及操作\n\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| lpush| lpush key value| 将一个或多个值插入到已存在的列表头部|\n|2| rpush| rpush key value| 将一个或多个值插入到已存在的列表尾部|\n|3| linsert| linsert key before/after pivot value|在列表的元素前或后插入元素|\n|4| lset| lset key index value|通过索引设置列表元素的值|\n|5| lrem| lrem key count value|移除列表元素|\n|6| ltrim| ltrim key start stop| 对一个列表进行修剪(trim), 列表保留指定区域内的元素|\n|7| lrange| lrange key start stop|获取列表中的某一片段|\n|8| lpop| lpop key|移出并获取列表的第一个元素|\n|9| rpop| rpop key|移出兵获取列表的最后一个元素|\n|10|rpoplpush| rpoplpush source destination|移除列表的最后一个元素,并将该元素添加到另外一个列表并返回|\n|11|lindex| lindex key index|通过索引获取列表的元素|\n|12|llen| llen key|获取列表长度|\n\n\n## Redis中hash类型及操作\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| hset| hset key field value|将哈希表中key中字段field的值设为value|\n|2| hget| hget key field|获取储存在哈希表中指定字段的值|\n|3| hmget| hmget key field1 ... fieldN|获取所有给定字段的值|\n|4| hmset| hmset key field1 value1 ... fieldN valueN|同时设置到哈希表中多个field|\n|5| hincrby| hincrby key filed increment|为哈希表key中指定字段加上给定值|\n|6| hexists| hexists key field|查看哈希表key中是否存在filed字段|\n|7| hdel | hdel key field| 删除一个或多个哈希字段|\n|8| hlen| hlen key|获取哈希表中字段的数量|\n|9| hkeys| hkeys key|获取哈希表中所有字段|\n|10|hvals| hvals key|获取哈希表中所有的值|\n|11|hgetall| hgetall key|获取哈希表中指定key的所有字段和值|\n\n\n## Redis中sets类型及操作\n\n数学中的集合,对集合进行添加,删除以及获取交集差集等操作.\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| sadd| sadd key member1[ member2]|向集合中添加一个或者多个元素|\n|2| srem| srem key member1[ member2]|移除集合中一个或者多个元素|\n|3| smembers| smembers key|返回集合中所有元素|\n|4| spop| spop key|移除并返回集合中的一个随机元素|\n|5| sdiff| sdiff key1[key2]|返回key2中没有key1的所有元素差集|\n|6| sdiffstore| sdiffstore destination key1 key2|返回给定所有集合的差集兵存储在destination中|\n|7| sinter|sinter key1 key2| 返回给定所有集合的交集|\n|8| sinterstore| sinterstore destination key1 key2|返回给定所有集合的交集并存储在destination中|\n|9| sunion| sunion key1 key2| 返回给定所有集合的并集|\n|10|sunionstore|sunionstore destination key1 key2|返回所有给定集合的并集 存储在destination中|\n|11|smove| smove source destination member| 将member元素从source集合移动到destination集合|\n|12|scard| scard key member|获取集合成员数|\n|13|sismember|sismember key member|判断member元素是否是集合key的成员|\n|14|srandmember| srandmember key[count]|返回集合中一个或多个随机数|\n\n## Redis中zsets类型及操作\n\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| zadd| zadd key score1 member|添加member元素到集合key, 若元素在集合中存在,则更新对应的score|\n|2| zrem| zrem key member| 删除指定元素,1表示成功,如果元素不存在则返回0|\n|3| zincrby| zincby key incr member| 有序集合中对指定成员的score增加对应增量,返回更新后的score值|\n|4| zrank| zrank key member|返回有序集合中指定成员的索引|\n|5| zrevrank| zrevrank key member| 返回有序集合中指定成员的排名,有序集合成员按分数值递减排序|\n|6| zrange| zrange key start end|通过索引区间返回有序集合成指定区域内的成员|\n|7| zrevrange| zrevrange key start end|返回集合中指定区间内的成员,通过索引,分数从高到低|\n|8| zrangebyscore| zrangebyscore key min max| 通过分数返回有序集合指定区间内的成员|\n|9| zcount| zcount key min max|计算在有序集合中指定区间分数的成员数|\n|10|zcard| zcard key| 获取有序集合的成员数|\n|11|zscore|zscore key element| 返回有序集合中,成员的分数值|\n|12|zremrangebyrank| zremrangebyrank key min max| 移除有序集合中给定的排名区间的所有成员|\n|13|zremrangebyscore| zremrangebyscore key min max| 移除有序集合中给定的分数区间的所有成员|\n\n\n## Redis中常用命令及操作 \n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| keys| keys pattern| 返回符合给定要求的所有key|\n|2| exists| exists key| 判断key是否存在|\n|3| del| del key| 删除一个key|\n|4| expire| expire key seconds| 设置一个key的过期时间, 单位:秒|\n|5| move| move key db| 当前key 移到其它db数据库中|\n|6| persist| persist key| 移除key的过期时间|\n|7| randomkey| randomkey -| 随机返回key空间的一个key|\n|8| rename| rename key| 重命名key|\n|9| type| type key| 返回key所对应value的类型|\n\n## Redis中的订阅/发布\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| subscribe| subscribe channel| 订阅给定的一个或多个频道的信息|\n|2| publish| publish channel message| 将信息发送给指定的频道 channel|\n|3| psubscribe | psubscribe pattern| 订阅一个或多个符合给定模式的频道|\n|4| pubsub| pubsub subcommand| 查看订阅与发布系统状态|\n|5| punsubscribe| punsubscrib pattern|退出所有给定模式的频道|\n|6| unsubscribe| unsubscribe channel| 退出给定的频道|\n\n## Redis服务器的相关命令\n|序号|命令|格式|解释|\n|:----:|:----:|:----|:----|\n|1| ping| ping [message]|测试连接是否存活|\n|2| echo| echo message|在命令行打印一些内容|\n|3| select| select index| 选择数据库|\n|4| quit| quit | 退出连接|\n|5| dbsize| dbsize| 返回当前数据库中key的数目|\n|6| info| info section| 获取服务器的信息和统计|\n|7| config get| config get|获取服务器配置信息|\n|8| flushdb| flushdb| 删除当前选择数据库中的所有key|\n|9| flushall| flushall| 删除所有数据库中的所有key|\n\n# Redis主从复制实现\n\n1. 首先创建 6380 6381两个文件夹,复制`redis.conf`至目录下,并修改配置文件端口号与文件夹一致\n2. 开启服务 `redis-server ./6380/redis.conf`、`redis-server ./6381/redis.conf`\n3. 创建实例连接服务端`redis-cli -p 6380`、`redis-cli -p 6381`\n4. 在`6380`端口数据库中使用 `slaveof 127.0.0.1 6381` 配置主从\n    \n返回 `ok` 后 在`6380`端口客户端执行 `info replication`查看信息(我本地是windows测试)\n\n```\nE:\\>\\soft\\redis\\redis-cli -p 6380\n127.0.0.1:6380> info replication\n# Replication\nrole:slave # 当前角色 slave 代表从数据库\nmaster_host:127.0.0.1   # 主数据库IP\nmaster_port:6381        # 主数据库端口\nmaster_link_status:up\nmaster_last_io_seconds_ago:7\nmaster_sync_in_progress:0\nslave_repl_offset:141\nslave_priority:100\nslave_read_only:1\nconnected_slaves:0\nmaster_repl_offset:0\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n127.0.0.1:6380>\n```\n\n在`6381`端口客户端执行 `info replication` 查看信息(本地windows)\n```\nE:\\>\\soft\\redis\\redis-cli -p 6381\n127.0.0.1:6381> info replication\n# Replication\nrole:master # 当前角色 master 代表主数据库\nconnected_slaves:1 # 已连接从数据库数量\nslave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=0\nmaster_repl_offset:281\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:2\nrepl_backlog_histlen:280\n127.0.0.1:6381>\n```\n\n5. 停止端口号为`6381`的redis服务器(模拟`6381`主服务器出现问题无法使用等情况)\n6. 开启端口号为`6381`的redis服务器,并设定`6381`端口数据库为端口号`6380`数据库的从库\n```\nredis-server --port 6380 --slaveof 127.0.0.1 6381\n```\n连接端口号为`6381`的redis客户端,使用`info replication`命令查询状态\n```\n127.0.0.1:6381> info replication\n# Replication\nrole:master\nconnected_slaves:1\nslave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=0\nmaster_repl_offset:281\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:2\nrepl_backlog_histlen:280\n127.0.0.1:6381>\n```\n\n> 权限认证\n\n\n为了安全,通常`master`主库配置文件中会使用`requirepass`,而在`slave`从库中要做`masterauth`权限认证\n\n\n\n## 跨IP连接Redis-server\n\n以IP为`192.168.44.130`作为`Redis-sever`,以`192.168.44.128`作为`Redis-cli`连接\n\n修改`Redis-server`配置文件,保证`protected-mode`值为`yes`,查找`bind` 注释掉`bind 127.0.0.1`\n\n查找 `requirepass`, 在下方写入(注意密码复杂度)\n```\nrequirepass myPass\n```\n\n保存退出\n\n在IP为`192.168.44.128`客户端上输入一下命令尝试连接`Reids-server`\n```\n# 连接Redis-server\nredis-cli -h 192.168.44.130 -p 6379\nAUTH myPass\n```\n\n\n## Redis哨兵的创建与实现\n\n建立哨兵方式 1:\n\n> redis-sentinel /path/to/sentinel.conf\n\n建立哨兵方式 2:\n\n> redis-server /path/to/sentinel.conf --sentinel\n\n`Sentinel`的配置\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 60000\n```\n\n解析:\n\n> 其中`mymaster`表示要监控的主数据库的名字,后两个参数表示主数据库的地址和端口号,这里我们要监控的是主数据库6379, 最后的`2`表示最低通过票数,当集群中有2个哨兵认为`mymaster`挂掉时,才能真正认为该master已经不可用了.而`down-after-milliseconds`表示每隔一定时间(单位:毫秒)发送一个`ping`命令,请求Server响应,来判断主数据库是否可用","tags":["Redis"]}]